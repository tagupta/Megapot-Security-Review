_Note: Not all issues are guaranteed to be correct._

## Low Severity Findings

### Unsafe Minting without ERC721Receiver Check

**Severity:** Low 

**Targets:**
- mintTicket (JackpotTicketNFT)

**Description:**

The mintTicket function uses ERC721._mint instead of the safer _safeMint, so it does not perform the onERC721Received compatibility check on the recipient. If a ticket is minted to a smart contract that does not implement onERC721Received, the token will be irreversibly locked in that contract.

**Root cause:**

Misuse of ERC721._mint bypasses the ERC721Receiver hook, omitting any validation that the recipient contract can handle ERC721 tokens.

**Impact:**

Tickets minted to incompatible contracts become permanently inaccessible, potentially causing users to lose their tickets permanently.

---

### tokenURI Override Breaks ERC-721 Metadata Standard and Existence Guarantees

**Severity:** Low 

**Targets:**
- tokenURI (JackpotTicketNFT)

**Description:**

The JackpotTicketNFT contract overrides ERC721’s tokenURI function as a pure method that always returns an empty string, completely shadowing the inherited metadata logic. This not only violates the ERC-721 Metadata extension standard (which requires a valid URI per token), but also bypasses the essential _exists(tokenId) check, resulting in silent default responses for non-existent tokens.

**Root cause:**

The tokenURI override is declared `pure` and unconditionally returns `""`, preventing any access to contract state or invocation of `super.tokenURI`. No base URI or per-token URI mapping is implemented, and there is no existence guard, so both metadata provisioning and validity checks are completely disabled.

**Impact:**

— All tokens report an empty metadata URI, breaking marketplaces, wallets, and tooling that depend on JSON metadata (name, image, attributes).
— Calls to tokenURI with unminted IDs no longer revert but return an empty string, masking invalid queries and potentially causing downstream logic errors or misinterpretations.
— Violates ERC-721 Metadata interface conformance, undermining token discoverability and user trust.

---

### Inconsistent and Missing Event Emissions Across Contracts

**Severity:** Low 

**Targets:**
- setEntropyProvider (ScaledEntropyProvider)
- constructor (Jackpot)
- initializeJackpot (Jackpot)

**Description:**

Several functions and the constructor in the Jackpot and ScaledEntropyProvider contracts fail to properly emit, conditionally guard, or consistently log critical state changes. This leads to gaps and noise in the event history that off-chain systems rely on for auditing, monitoring, and business logic.

**Root cause:**

Across multiple modules, state-mutating operations (constructor initialization and setter functions) either omit the required event emission or emit superfluous events without checking for actual changes. There is no unified pattern ensuring every critical state change is logged exactly once with accurate parameters.

**Impact:**

Off-chain indexers, analytics platforms, and user interfaces will encounter:
- Missing events for essential configuration changes (entropy provider updates, initial referral fee, ticket purchase enabling), causing blind spots in governance and audit trails.
- Redundant or spurious events (ticket price updates with no actual change), leading to wasted processing, false business triggers, and unnecessary costs.
- Incomplete or noisy historical data, undermining trust in the platform’s transparency and potentially causing financial or operational discrepancies.

---

### Redundant TicketPriceUpdated Event Emission

**Severity:** Low 

**Targets:**
- setTicketPrice (Jackpot)

**Description:**

The setTicketPrice function always emits a TicketPriceUpdated event and calls the LP manager, even when the new ticket price equals the current value. This leads to redundant logs that do not correspond to any real state change.

**Root cause:**

Lack of a conditional guard to prevent event emission when the new ticket price matches the existing ticketPrice.

**Impact:**

Off-chain systems relying solely on TicketPriceUpdated events to detect genuine price changes may be misled by spurious events. This causes wasted processing, potential false triggers of business logic, and unnecessary transaction costs.

---

### Owner-Controlled Global Fee and Threshold Settings Enable Retroactive Fee Manipulation

**Severity:** Low 

**Targets:**
- scaledEntropyCallback (Jackpot)
- _transferProtocolFee (Jackpot)
- _transferProtocolFee / setProtocolFee (Jackpot)
- setProtocolFee (Jackpot)
- _transferProtocolFee / setProtocolFeeThreshold (Jackpot)

**Description:**

The Jackpot contract uses global, owner-mutable variables for both protocol fees (`protocolFee`) and fee thresholds (`protocolFeeThreshold`). These values are read dynamically at settlement time (in `_transferProtocolFee`) rather than snapshotted when a drawing is locked. Because the owner can update these parameters at any time—including after users purchase tickets or a drawing is locked but before the settlement callback executes—they can retroactively alter fees charged to participants.

**Root cause:**

Critical economic parameters (`protocolFee` and `protocolFeeThreshold`) are stored in single, mutable contract‐level variables protected only by `onlyOwner`. There is no per-drawing snapshot of these values when a draw is initiated or locked, nor are there timing guards, timelocks, or multisig controls to prevent mid-draw updates.

**Impact:**

• Retroactive fee hikes: The owner can increase `protocolFee` after ticket sales but before settlement, reducing winners’ payouts beyond what they expected.
• Retroactive threshold shifts: By adjusting `protocolFeeThreshold` mid-draw, the owner can change the fee calculation logic for an active draw, siphoning more or less funds unpredictably.
• Undermined fairness and trust: Participants cannot lock in expected fee rates when buying tickets, opening up economic exploitation and breaking the promise of fixed fees per drawing.
• Potential regulatory and reputational risk: Such retroactive changes to protocol economics may violate user expectations and any off-chain guarantees or legal disclosures.

---

### Input Validation Errors in ScaledEntropyProvider Lead to Denial-of-Service and Fund Loss

**Severity:** Low 

**Targets:**
- getFee and requestAndCallbackScaledRandomness (ScaledEntropyProvider)
- requestAndCallbackScaledRandomness (ScaledEntropyProvider)

**Description:**

The ScaledEntropyProvider contract fails to validate critical inputs and manage user‐supplied ether properly, resulting in both denial-of-service of randomness requests and permanent overpayment losses.

**Root cause:**

ScaledEntropyProvider blindly delegates a user‐provided _gasLimit to the underlying entropy oracle (entropy.getFeeV2 and entropy.requestV2) without enforcing any minimum or maximum bounds, and it forwards the entire msg.value to the oracle without refunding any surplus above the quoted fee.

**Impact:**

1. A caller can specify a gas limit of zero, causing the entropy oracle to quote a zero fee. Subsequent requestAndCallbackScaledRandomness calls succeed with msg.value=0 but leave no gas reserved for the callback, guaranteeing its failure and permanently denying randomness delivery to the user.
2. A malicious user can supply an excessively large gas limit to generate an astronomically high fee quote, potentially locking up user funds or deterring legitimate requests.
3. Users who overpay msg.value above the required fee never receive a refund of the surplus, resulting in unintended financial loss and poor user experience.

---

### Integer Division Truncation Causes Unallocated ‘Dust’ Across Multiple Modules

**Severity:** Low 

**Targets:**
- _calculateAndStoreTierPayouts (GuaranteedMinimumPayoutCalculator)
- _payReferrersWinnings (Jackpot)
- _validateAndTrackReferrals (Jackpot)
- _consolidateWithdrawals (JackpotLPManager)
- processDrawingSettlement (JackpotLPManager)
- processInitiateWithdraw (via _consolidateDeposits and _consolidateWithdrawals) (JackpotLPManager)

**Description:**

Multiple contracts (GuaranteedMinimumPayoutCalculator, Jackpot, JackpotLPManager) perform fixed-point or weighted calculations using Solidity’s integer division, which floors any fractional results. In each case—tiered prize distributions, referral fee splits, and LP share↔asset conversions—these truncated remainders (“dust”) are neither tracked nor redistributed. Over time, the unallocated dust accumulates in the contracts, permanently locking small amounts of tokens or USDC.

**Root cause:**

Reliance on Solidity’s floor (integer) division for fixed-point arithmetic or weighted disbursements without capturing, reconciling, or returning truncated fractional remainders.

**Impact:**

Accumulated dust reduces user payouts and LP withdrawals slightly but cumulatively, leading to unfair withholding of funds, misaligned accounting, and potential erosion of trust. Locked tokens cannot be recovered, benefiting no rightful party and effectively granting unintended profit to contract holders.

---

### Unchecked uint8 Downcast in Drawing Initialization

**Severity:** Low 

**Targets:**
- _setNewDrawingState (Jackpot)

**Description:**

In Jackpot._setNewDrawingState, the calculation for the new bonus ball count casts a uint256 result—Math.max(bonusballMin, ceilDiv(minNumberTickets, combosPerBonusball))—directly to uint8 without validating that it fits within 8 bits. Depending on compiler settings or Solidity version, this unguarded narrowing conversion can either revert the transaction when the result exceeds 255 (default checked casts in >=0.8) or silently wrap modulo 256 (e.g., under unchecked blocks or earlier versions). Either outcome breaks the drawing initialization logic.

**Root cause:**

The code assumes the computed bonus ball count will always be ≤255, but performs no explicit bound checks or capping before casting a potentially much larger uint256 to uint8.

**Impact:**

If an attacker or misconfiguration causes ceilDiv(minNumberTickets, combosPerBonusball) to exceed 255, one of two failure modes occurs: (1) A checked downcast reverts, aborting _setNewDrawingState and halting any new drawings until the contract is fixed. (2) An unchecked downcast wraps the value, producing an incorrect bonus ball count (e.g., zero or a small number), corrupting the drawing configuration, prize calculations, and ticket validation.

---

### Fee-on-Transfer Token Accounting Mismatch in lpDeposit

**Severity:** Low 

**Targets:**
- lpDeposit (Jackpot)

**Description:**

The lpDeposit function uses SafeERC20.safeTransferFrom to pull tokens and then calls processDeposit with the original _amountToDeposit parameter. If the token charges a transfer fee (fee-on-transfer or deflationary token), the contract will receive fewer tokens than _amountToDeposit, but internal accounting will credit the full amount. This creates a permanent mismatch between the contract’s actual token balance and recorded LP deposits.

**Root cause:**

Reliance on the user-supplied _amountToDeposit parameter for accounting instead of measuring the actual token balance change after transfer, with no reconciliation step.

**Impact:**

Attackers or users depositing with a fee-on-transfer token will cause the contract to record more tokens than it holds, leading to underfunded LP credits. Over time, this shortfall could be exploited to withdraw unbacked tokens or drain funds, harming LPs and the protocol’s solvency.

---

### Premature runJackpot Advances Uninitialized Jackpot Drawing

**Severity:** Low 

**Targets:**
- runJackpot and scaledEntropyCallback (Jackpot)
- runJackpot (Jackpot)

**Description:**

The Jackpot contract allows anyone to call runJackpot (and trigger its entropy callback) on the initial drawing (currentDrawingId == 0) before the owner has seeded and initialized the jackpot via initializeJackpot. Because drawingTime defaults to zero and jackpotLock is false on drawing 0, runJackpot’s prechecks pass. It locks the drawing, requests randomness, and the callback scaledEntropyCallback unconditionally calls _setNewDrawingState, advancing currentDrawingId to 1. After this, initializeJackpot (which requires currentDrawingId == 0) permanently reverts, leaving the contract uninitialized and its core functionality disabled.

**Root cause:**

runJackpot and its entropy callback do not verify that initializeJackpot has been called or that the current drawing is properly initialized before advancing the drawing state. There is no require guard enforcing currentDrawingId > 0 or an initialized flag, allowing state progression on an uninitialized contract.

**Impact:**

An attacker can front‐run the owner, prematurely start and settle the jackpot without LP seeding or ticket sales, corrupt prize pool state, and permanently block the official initializeJackpot call. This results in a denial-of-service of the jackpot’s core operations, halting ticket purchases, random draws, and fund distributions.

---

### Small deposits can be irretrievably locked by zero-share consolidation

**Severity:** Low 

**Targets:**
- _consolidateDeposits (and emergencyWithdrawLP) (JackpotLPManager)

**Description:**

When consolidating a user’s lastDeposit from a prior drawing into consolidatedShares, the contract uses floor division `(amount * PRECISE_UNIT) / drawingAccumulator`. If the deposit is small enough that this yields zero, the code still deletes the lastDeposit record. In both the normal withdrawal path and emergencyWithdrawLP, that raw deposit is never reimbursed if it produced zero shares and was deleted, effectively locking the user’s funds in the contract.

**Root cause:**

Unconditional deletion of lastDeposit after zero-share floor division leads to loss of the raw deposit record when the division truncates to zero.

**Impact:**

Users making very small deposits can end up with neither shares nor a raw deposit record, preventing any withdrawal or emergency recovery of their USDC.

---

### Packed Array Collision in EIP-712 Claim Hash

**Severity:** Low 

**Targets:**
- createClaimTicketEIP712Hash (JackpotBridgeManager)

**Description:**

The function builds its EIP-712 message by hashing CLAIM_TICKET_TYPEHASH, keccak256(abi.encodePacked(_ticketIds)), and the recipient address. By using abi.encodePacked on a dynamic uint256[] without including array length or separators, two distinct ticket ID sequences can serialize to the same byte stream and yield identical hashes. An attacker can exploit this to present a forged or replayed signature over one sequence and substitute a different, colliding sequence of tickets during claimTickets().

**Root cause:**

Use of abi.encodePacked on a dynamic array omits array length and element boundaries, breaking input injectivity and enabling collisions.

**Impact:**

Malicious actors can claim or transfer tickets they did not possess by replaying or forging valid signatures over colliding ticket ID sequences, leading to unauthorized NFT transfers and asset loss.

---

### Insufficient Validation of Referrer Inputs Enables Fee Drain Attacks

**Severity:** Low 

**Targets:**
- _validateAndTrackReferrals (Jackpot)
- buyTickets (Jackpot)

**Description:**

The `_validateAndTrackReferrals` helper does not enforce critical invariants on the `_referrers` array passed in by users of `buyTickets`. Specifically, it fails to (1) ensure that referrer addresses are unique and (2) block the buyer (`msg.sender`) from listing themselves as a referrer. Attackers can exploit these omissions to credit all referral rewards to themselves, draining the referral fee reserve or offsetting their ticket purchase costs entirely.

**Root cause:**

The `_validateAndTrackReferrals` function lacks validation logic to enforce uniqueness of referrer addresses and to reject entries matching `msg.sender`. As a result, duplicate addresses and self-referral entries are processed independently, allocating full portions of the referral fee to the same attacker-controlled address.

**Impact:**

An attacker can manipulate the referral tracking to receive the entire fee pool intended for multiple distinct referrers or to recoup the full cost of their ticket. This results in financial loss for the protocol and undermines fair distribution of referral rewards.

---

### Missing enforcement of sale period and lock state in buyTickets

**Severity:** Low 

**Targets:**
- buyTickets (Jackpot)

**Description:**

The buyTickets function (and its helpers _validateBuyTicketInputs, _validateAndStoreTickets) does not enforce the intended sale window or the drawing’s locked state. There are no validations against block.timestamp (before sale start or after drawingTime) or the jackpotLock flag. As a result, tickets can be purchased outside the documented sale period or after the drawing has been locked by runJackpot.

**Root cause:**

Absence of require() checks in buyTickets and internal validation functions for both the sale window (block.timestamp constraints) and the locked state (DrawingState.jackpotLock).

**Impact:**

Users can buy tickets at any time—before sales should start, after sales should end, or after the drawing has been locked—undermining lottery fairness, skewing odds, misallocating prize funds, and potentially causing financial loss to participants or the protocol.
